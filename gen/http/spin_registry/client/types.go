// Code generated by goa v3.2.6, DO NOT EDIT.
//
// spin-registry HTTP client types
//
// Command:
// $ goa gen code.hollensbe.org/erikh/spin/design

package client

import (
	spinregistry "code.hollensbe.org/erikh/spin/gen/spin_registry"
	goa "goa.design/goa/v3/pkg"
)

// CreateRequestBody is the type of the "spin-registry" service "create"
// endpoint HTTP request body.
type CreateRequestBody struct {
	// Name of VM; does not need to be unique
	Name string `form:"name" json:"name" xml:"name"`
	// CPU count
	Cpus uint `form:"cpus" json:"cpus" xml:"cpus"`
	// Memory (in megabytes)
	Memory uint `form:"memory" json:"memory" xml:"memory"`
	// Storage references
	Storage []*StorageRequestBody `form:"storage" json:"storage" xml:"storage"`
}

// UpdateRequestBody is the type of the "spin-registry" service "update"
// endpoint HTTP request body.
type UpdateRequestBody struct {
	// VM to publish
	VM *VMRequestBody `form:"vm" json:"vm" xml:"vm"`
}

// GetResponseBody is the type of the "spin-registry" service "get" endpoint
// HTTP response body.
type GetResponseBody struct {
	// Name of VM; does not need to be unique
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// CPU count
	Cpus *uint `form:"cpus,omitempty" json:"cpus,omitempty" xml:"cpus,omitempty"`
	// Memory (in megabytes)
	Memory *uint `form:"memory,omitempty" json:"memory,omitempty" xml:"memory,omitempty"`
	// Storage references
	Storage []*StorageResponseBody `form:"storage,omitempty" json:"storage,omitempty" xml:"storage,omitempty"`
}

// StorageRequestBody is used to define fields on request body types.
type StorageRequestBody struct {
	// Volume name, must not include `/`
	Volume string `form:"volume" json:"volume" xml:"volume"`
	// Image filename, must not include `/`
	Image string `form:"image" json:"image" xml:"image"`
	// Image size (in gigabytes)
	ImageSize uint `form:"image_size" json:"image_size" xml:"image_size"`
	// Is this image a cdrom?
	Cdrom *bool `form:"cdrom,omitempty" json:"cdrom,omitempty" xml:"cdrom,omitempty"`
}

// VMRequestBody is used to define fields on request body types.
type VMRequestBody struct {
	// Name of VM; does not need to be unique
	Name string `form:"name" json:"name" xml:"name"`
	// CPU count
	Cpus uint `form:"cpus" json:"cpus" xml:"cpus"`
	// Memory (in megabytes)
	Memory uint `form:"memory" json:"memory" xml:"memory"`
	// Storage references
	Storage []*StorageRequestBody `form:"storage" json:"storage" xml:"storage"`
}

// StorageResponseBody is used to define fields on response body types.
type StorageResponseBody struct {
	// Volume name, must not include `/`
	Volume *string `form:"volume,omitempty" json:"volume,omitempty" xml:"volume,omitempty"`
	// Image filename, must not include `/`
	Image *string `form:"image,omitempty" json:"image,omitempty" xml:"image,omitempty"`
	// Image size (in gigabytes)
	ImageSize *uint `form:"image_size,omitempty" json:"image_size,omitempty" xml:"image_size,omitempty"`
	// Is this image a cdrom?
	Cdrom *bool `form:"cdrom,omitempty" json:"cdrom,omitempty" xml:"cdrom,omitempty"`
}

// NewCreateRequestBody builds the HTTP request body from the payload of the
// "create" endpoint of the "spin-registry" service.
func NewCreateRequestBody(p *spinregistry.VM) *CreateRequestBody {
	body := &CreateRequestBody{
		Name:   p.Name,
		Cpus:   p.Cpus,
		Memory: p.Memory,
	}
	if p.Storage != nil {
		body.Storage = make([]*StorageRequestBody, len(p.Storage))
		for i, val := range p.Storage {
			body.Storage[i] = marshalSpinregistryStorageToStorageRequestBody(val)
		}
	}
	return body
}

// NewUpdateRequestBody builds the HTTP request body from the payload of the
// "update" endpoint of the "spin-registry" service.
func NewUpdateRequestBody(p *spinregistry.UpdateVM) *UpdateRequestBody {
	body := &UpdateRequestBody{}
	if p.VM != nil {
		body.VM = marshalSpinregistryVMToVMRequestBody(p.VM)
	}
	return body
}

// NewGetVMOK builds a "spin-registry" service "get" endpoint result from a
// HTTP "OK" response.
func NewGetVMOK(body *GetResponseBody) *spinregistry.VM {
	v := &spinregistry.VM{
		Name:   *body.Name,
		Cpus:   *body.Cpus,
		Memory: *body.Memory,
	}
	v.Storage = make([]*spinregistry.Storage, len(body.Storage))
	for i, val := range body.Storage {
		v.Storage[i] = unmarshalStorageResponseBodyToSpinregistryStorage(val)
	}

	return v
}

// ValidateGetResponseBody runs the validations defined on GetResponseBody
func ValidateGetResponseBody(body *GetResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.Cpus == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("cpus", "body"))
	}
	if body.Memory == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("memory", "body"))
	}
	if body.Storage == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("storage", "body"))
	}
	for _, e := range body.Storage {
		if e != nil {
			if err2 := ValidateStorageResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateVMRequestBody runs the validations defined on VMRequestBody
func ValidateVMRequestBody(body *VMRequestBody) (err error) {
	if body.Storage == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("storage", "body"))
	}
	return
}

// ValidateStorageResponseBody runs the validations defined on
// StorageResponseBody
func ValidateStorageResponseBody(body *StorageResponseBody) (err error) {
	if body.Volume == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("volume", "body"))
	}
	if body.Image == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("image", "body"))
	}
	if body.ImageSize == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("image_size", "body"))
	}
	return
}
